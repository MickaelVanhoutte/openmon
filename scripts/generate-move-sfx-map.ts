import fs from 'fs';
import path from 'path';

interface BattleUtilitySound {
	key: string;
	filename: string;
}

// Battle utility sounds that are in the move-effects folder
const BATTLE_UTILITY_SOUNDS: BattleUtilitySound[] = [
	{ key: 'hit-normal', filename: 'Hit Normal Damage' },
	{ key: 'hit-super-effective', filename: 'Hit Super Effective' },
	{ key: 'hit-not-very-effective', filename: 'Hit Weak Not Very Effective' },
	{ key: 'faint', filename: 'In-Battle Faint No Health' },
	{ key: 'stat-rise', filename: 'Stat Rise Up' },
	{ key: 'stat-fall', filename: 'Stat Fall Down' },
	{ key: 'status-burned', filename: 'Status Burned' },
	{ key: 'status-confused', filename: 'Status Confused' },
	{ key: 'status-frozen', filename: 'Status Frozen' },
	{ key: 'status-paralyzed', filename: 'Status Paralyzed' },
	{ key: 'status-poisoned', filename: 'Status Poisoned' },
	{ key: 'status-sleep', filename: 'Status Sleep' },
	{ key: 'ability-activate', filename: 'In-Battle Ability Activate' },
	{ key: 'eat-berry', filename: 'In-Battle Eat Berry' },
	{ key: 'heal', filename: 'In-Battle Heal HP Restore' },
	{ key: 'health-low', filename: 'In-Battle Health Low' },
	{ key: 'held-item', filename: 'In-Battle Held Item Activate' },
	{ key: 'switch-alive', filename: 'In-Battle Recall Switch Alive' },
	{ key: 'switch-fainted', filename: 'In-Battle Recall Switch Fainted' },
	{ key: 'switch-flee', filename: 'In-Battle Recall Switch Flee Run' },
	{ key: 'switch-forced', filename: 'In-Battle Recall Switch Forced Retreat' },
	{ key: 'switch-pokeball', filename: 'In-Battle Recall Switch Pokeball' }
];

function kebabToTitleCase(kebab: string): string {
	return kebab
		.split('-')
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join(' ');
}

function findSFXFile(moveName: string, sfxFiles: string[]): string | undefined {
	// Convert kebab-case to Title Case
	const titleCase = kebabToTitleCase(moveName);

	// Try exact match first
	if (sfxFiles.includes(`${titleCase}.mp3`)) {
		return titleCase;
	}

	// Try with hyphens preserved (e.g., Double-Edge, Baby-Doll Eyes)
	const withHyphens = moveName
		.split('-')
		.map((word, index) => {
			if (index === 0) {
				return word.charAt(0).toUpperCase() + word.slice(1);
			}
			// Keep hyphen before next word if it's a single letter or special case
			return word.charAt(0).toUpperCase() + word.slice(1);
		})
		.join('-');

	if (sfxFiles.includes(`${withHyphens}.mp3`)) {
		return withHyphens;
	}

	// Try case-insensitive match
	const lowerMoveName = moveName.toLowerCase();
	const match = sfxFiles.find(
		(file) =>
			file.toLowerCase().replace('.mp3', '') === lowerMoveName ||
			file.toLowerCase().replace('.mp3', '') === titleCase.toLowerCase()
	);

	if (match) {
		return match.replace('.mp3', '');
	}

	return undefined;
}

function generateMaps(): void {
	// Read SFX files
	const sfxDir = path.join(process.cwd(), 'src/assets/audio/move-effects');
	const sfxFiles = fs.readdirSync(sfxDir).filter((f) => f.endsWith('.mp3'));

	// Remove multi-part variants (keep only main files)
	const mainSfxFiles = sfxFiles.filter((file) => !/ part \d+\.mp3$/.test(file));

	// Read Pokedex JSON
	const pokedexPath = path.join(
		process.cwd(),
		'src/assets/data/final/beta/pokedex-animatedV3.json'
	);
	const pokedexData = JSON.parse(fs.readFileSync(pokedexPath, 'utf-8'));

	// Extract unique move names
	const moveNames = new Set<string>();
	pokedexData.forEach((pokemon: Record<string, unknown>) => {
		if (pokemon.moves && Array.isArray(pokemon.moves)) {
			pokemon.moves.forEach((move: Record<string, unknown>) => {
				if (typeof move.name === 'string') {
					moveNames.add(move.name);
				}
			});
		}
	});

	// Generate MOVE_SFX_MAP
	const moveSfxMap: Record<string, string> = {};
	const unmatchedMoves: string[] = [];

	Array.from(moveNames)
		.sort()
		.forEach((moveName) => {
			const sfxFile = findSFXFile(moveName, mainSfxFiles);
			if (sfxFile) {
				moveSfxMap[moveName] = sfxFile;
			} else {
				unmatchedMoves.push(moveName);
			}
		});

	// Generate BATTLE_SFX_MAP
	const battleSfxMap: Record<string, string> = {};
	BATTLE_UTILITY_SOUNDS.forEach(({ key, filename }) => {
		battleSfxMap[key] = filename;
	});

	// Generate TypeScript code
	const tsCode = `// Auto-generated by scripts/generate-move-sfx-map.ts
// DO NOT EDIT MANUALLY

export interface AudioCue {
	soundId: string;
	offset: number;
	volume?: number;
}

export interface MoveAudioConfig {
	impact?: AudioCue;
	charge?: AudioCue;
	ambient?: AudioCue;
}

export const MOVE_SFX_MAP: Record<string, string> = {
${Object.entries(moveSfxMap)
	.map(([key, value]) => `	'${key}': '${value}'`)
	.join(',\n')}
};

export const BATTLE_SFX_MAP: Record<string, string> = {
${Object.entries(battleSfxMap)
	.map(([key, value]) => `	'${key}': '${value}'`)
	.join(',\n')}
};

export function getMoveAudio(moveName: string): MoveAudioConfig | undefined {
	// Legacy function - kept for compatibility
	return undefined;
}

export async function playMoveSound(
	moveName: string,
	cueType: 'impact' | 'charge' | 'ambient',
	playFn: (soundId: string, volume: number) => void
): Promise<void> {
	// Legacy function - kept for compatibility
	return;
}

export function getMoveSFXPath(moveName: string): string | undefined {
	const sfxFile = MOVE_SFX_MAP[moveName.toLowerCase()];
	if (!sfxFile) {
		return undefined;
	}
	return \`src/assets/audio/move-effects/\${sfxFile}.mp3\`;
}

export function getBattleSFXPath(key: string): string | undefined {
	const sfxFile = BATTLE_SFX_MAP[key.toLowerCase()];
	if (!sfxFile) {
		return undefined;
	}
	return \`src/assets/audio/move-effects/\${sfxFile}.mp3\`;
}
`;

	// Write to audio-sync.ts
	const outputPath = path.join(process.cwd(), 'src/js/battle/animations/audio-sync.ts');
	fs.writeFileSync(outputPath, tsCode);

	console.warn(`✓ Generated MOVE_SFX_MAP with ${Object.keys(moveSfxMap).length} entries`);
	console.warn(`✓ Generated BATTLE_SFX_MAP with ${Object.keys(battleSfxMap).length} entries`);
	console.warn(`✓ Wrote to ${outputPath}`);

	if (unmatchedMoves.length > 0) {
		console.warn(`\n⚠ ${unmatchedMoves.length} unmatched moves (no SFX file found):`);
		unmatchedMoves.slice(0, 20).forEach((move) => {
			console.warn(`  - ${move}`);
		});
		if (unmatchedMoves.length > 20) {
			console.warn(`  ... and ${unmatchedMoves.length - 20} more`);
		}
	}
}

generateMaps();
